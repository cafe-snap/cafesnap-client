<p align="center">
  <img width="400" src="https://github.com/user-attachments/assets/5f4ef323-e3d9-45af-bf9e-a2c0dc9ab26d" />
</p>

<p align="center">
  <strong>
    CAFESNAP은 사용자가 가입한 네이버 카페의 게시글 중 동영상을 추출하여 보여주는 숏츠 플랫폼입니다.
  </strong>
  </br>
  <a href="https://github.com/cafe-snap/cafesnap-client">
    클라이언트
  </a>
  |
  <a href="https://github.com/cafe-snap/cafesnap-server">
    서버
  </a>
</p>

## 🗂 목차

<!-- toc -->

- [💭 프로젝트 동기](#%F0%9F%92%AD-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EB%8F%99%EA%B8%B0)
- [🛠 사용 기술](#%F0%9F%9B%A0-%EC%82%AC%EC%9A%A9-%EA%B8%B0%EC%88%A0)
    + [프론트엔드](#%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C)
    + [백엔드](#%EB%B0%B1%EC%97%94%EB%93%9C)
- [🎞 구현 기능 미리보기](#%F0%9F%8E%9E-%EA%B5%AC%ED%98%84-%EA%B8%B0%EB%8A%A5-%EB%AF%B8%EB%A6%AC%EB%B3%B4%EA%B8%B0)
- [📝 구현 세부사항](#%F0%9F%93%9D-%EA%B5%AC%ED%98%84-%EC%84%B8%EB%B6%80%EC%82%AC%ED%95%AD)
  * [1. 필요한 데이터를 가져오는 방법](#1-%ED%95%84%EC%9A%94%ED%95%9C-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%A5%BC-%EA%B0%80%EC%A0%B8%EC%98%A4%EB%8A%94-%EB%B0%A9%EB%B2%95)
    + [1-1. 네이버 API 와 제한 사항](#1-1-%EB%84%A4%EC%9D%B4%EB%B2%84-api-%EC%99%80-%EC%A0%9C%ED%95%9C-%EC%82%AC%ED%95%AD)
    + [1-2. 크롤링의 사용 이유](#1-2-%ED%81%AC%EB%A1%A4%EB%A7%81%EC%9D%98-%EC%82%AC%EC%9A%A9-%EC%9D%B4%EC%9C%A0)
    + [1-3. 필요한 데이터 크롤링 순서](#1-3-%ED%95%84%EC%9A%94%ED%95%9C-%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%81%AC%EB%A1%A4%EB%A7%81-%EC%88%9C%EC%84%9C)
  * [2. 동영상 데이터를 크롤링하는 방법](#2-%EB%8F%99%EC%98%81%EC%83%81-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%A5%BC-%ED%81%AC%EB%A1%A4%EB%A7%81%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95)
    + [2-1. 게시글의 동영상 포함 여부 확인](#2-1-%EA%B2%8C%EC%8B%9C%EA%B8%80%EC%9D%98-%EB%8F%99%EC%98%81%EC%83%81-%ED%8F%AC%ED%95%A8-%EC%97%AC%EB%B6%80-%ED%99%95%EC%9D%B8)
    + [2-2. 예상하지 못한 크롤링 결과 데이터](#2-2-%EC%98%88%EC%83%81%ED%95%98%EC%A7%80-%EB%AA%BB%ED%95%9C-%ED%81%AC%EB%A1%A4%EB%A7%81-%EA%B2%B0%EA%B3%BC-%EB%8D%B0%EC%9D%B4%ED%84%B0)
    + [2-3. 게시글로부터 동영상 데이터 확보](#2-3-%EA%B2%8C%EC%8B%9C%EA%B8%80%EB%A1%9C%EB%B6%80%ED%84%B0-%EB%8F%99%EC%98%81%EC%83%81-%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%99%95%EB%B3%B4)
- [🖼 사용자 경험 개선](#%F0%9F%96%BC-%EC%82%AC%EC%9A%A9%EC%9E%90-%EA%B2%BD%ED%97%98-%EA%B0%9C%EC%84%A0)
  * [1. 대기 시간 없는 영상 시청](#1-%EB%8C%80%EA%B8%B0-%EC%8B%9C%EA%B0%84-%EC%97%86%EB%8A%94-%EC%98%81%EC%83%81-%EC%8B%9C%EC%B2%AD)
    + [1-1. 초기 동영상 우선 제공](#1-1-%EC%B4%88%EA%B8%B0-%EB%8F%99%EC%98%81%EC%83%81-%EC%9A%B0%EC%84%A0-%EC%A0%9C%EA%B3%B5)
    + [1-2. 병렬 요청을 통한 나머지 카페의 동영상 제공](#1-2-%EB%B3%91%EB%A0%AC-%EC%9A%94%EC%B2%AD%EC%9D%84-%ED%86%B5%ED%95%9C-%EB%82%98%EB%A8%B8%EC%A7%80-%EC%B9%B4%ED%8E%98%EC%9D%98-%EB%8F%99%EC%98%81%EC%83%81-%EC%A0%9C%EA%B3%B5)
    + [1-3. 중복 없는 추가 동영상 제공](#1-3-%EC%A4%91%EB%B3%B5-%EC%97%86%EB%8A%94-%EC%B6%94%EA%B0%80-%EB%8F%99%EC%98%81%EC%83%81-%EC%A0%9C%EA%B3%B5)
  * [2. 동영상 개수 표기](#2-%EB%8F%99%EC%98%81%EC%83%81-%EA%B0%9C%EC%88%98-%ED%91%9C%EA%B8%B0)
    + [2-1. 영상의 재생 정도 표기](#2-1-%EC%98%81%EC%83%81%EC%9D%98-%EC%9E%AC%EC%83%9D-%EC%A0%95%EB%8F%84-%ED%91%9C%EA%B8%B0)
- [프로젝트 후기](#%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%ED%9B%84%EA%B8%B0)

<!-- tocstop -->

<br />

# 💭 프로젝트 동기

여가 시간을 좀 더 편리하게 즐기고자 하는 생각에서부터 출발한 프로젝트입니다.  
좋아하는 축구팀의 소식, 여러 여행지의 정보 등 저는 네이버 카페를 통하여 다양한 정보를 얻고, 또 많은 시간을 소비합니다. 특히, 축구팀의 경기가 있는 날 많은 양의 글이 올라오고 그 속에서 영상만 찾아보는 것이 꽤 불편하게 느껴져 이러한 불편함을 해소하고 싶었습니다.

이미 유튜브 숏츠, 인스타 릴스, 틱톡 등 다양한 숏츠 플랫폼이 존재하지만, 네이버 카페라는 폐쇄적인 특수성을 갖는 플랫폼은 마주한 적이 없었고, 나의 필요에 의한 것이니 더욱 흥미있게 또 그 속에 도전적인 요소가 많겠다고 생각 하며 프로젝트를 시작했습니다.

<br />

# 🛠 사용 기술

### 프론트엔드

![JAVASCRIPT](https://img.shields.io/badge/javascript-%23323330.svg?style=for-the-badge&logo=javascript&logoColor=%23F7DF1E)
![REACT](https://img.shields.io/badge/react-%2320232a.svg?style=for-the-badge&logo=react&logoColor=%2361DAFB)
![TAILWINDCSS](https://img.shields.io/badge/tailwindcss-%2338B2AC.svg?style=for-the-badge&logo=tailwind-css&logoColor=white)
![VITE](https://img.shields.io/badge/vite-%23646CFF.svg?style=for-the-badge&logo=vite&logoColor=white)

### 백엔드

![NODE.JS](https://img.shields.io/badge/node.js-5FA04E?style=for-the-badge&logo=node.js&logoColor=white)
![EXPRESS.JS](https://img.shields.io/badge/express.js-%23404d59.svg?style=for-the-badge&logo=express&logoColor=%2361DAFB)
![PUPPETEER](https://img.shields.io/badge/puppeteer-%40B5A4.svg?style=for-the-badge&logo=puppeteer&logoColor=white)

<br />

# 🎞 구현 기능 미리보기

<table>
  <tr>
    <td width="50%">
      <img width="100%" src="https://github.com/user-attachments/assets/25d58745-9e06-4dc2-9ee1-1f8b4fb0063d" />
    </td>
    <td width="50%">
      <img width="100%" src="https://github.com/user-attachments/assets/ab4401fb-c310-4510-871d-6e2af3e05642" />
    </td>
  </tr>
  <tr align="center">
    <td>카페별 동영상 시청</td>
    <td>동영상 검색 기능</td>
  </tr>
</table>
</br>

# 📝 구현 세부사항

## 1. 필요한 데이터를 가져오는 방법
> 크롤링(Crawling) = 웹 페이지의 데이터를 자동으로 가져오는 기술  

이 프로젝트에서 가장 중요한 데이터는 사용자가 가입한 카페의 목록과 동영상 2가지입니다.  
때문에, 이 2가지 데이터를 가져오는 방법에 대한 고민을 가장 먼저 시작했고 크롤링을 사용해 데이터를 가져왔습니다.

### 1-1. 네이버 API 와 제한 사항
>[네이버 API 목록](https://developers.naver.com/products/intro/plan/plan.md#네이버-오픈-api-목록)

네이버 카페의 게시글을 기반으로 하는 프로젝트인 만큼, 최우선 순위로 고려한 방법은 네이버 API를 사용하는 것이었습니다. 하지만 여러 제한 사항에 의해 네이버 API를 사용한다면 이 프로젝트를 완성할 수 없다고 판단했습니다.

1. <strong> 제공하지 않는 서비스 </strong>  
사용자가 가입한 카페의 목록을 제공하지 않습니다. 동영상 역시 마찬가지로, 동영상 자체를 제공해 주는 API는 없습니다.  
카페 게시글의 동영상을 얻고 싶다면 다음과 같은 순서를 따라야 합니다.  

&emsp;&emsp;&emsp;1-1. 검색 API를 사용하여 특정 키워드에 대한 검색을 진행합니다.  
&emsp;&emsp;&emsp;1-2. 해당 결과와 일치하는 반환값을 받습니다.  
&emsp;&emsp;&emsp;1-3. 반환된 여러 값들중 카페 게시글 URL 값을 찾아냅니다.  
&emsp;&emsp;&emsp;1-4. 해당 게시글 URL에 접속하여 DOM 요소를 통해 동영상 포함 여부를 확인합니다.  
&emsp;&emsp;&emsp;1-5. 크롤링 로직을 통해 동영상 데이터를 추출합니다.  
</br>
이처럼 직접적으로 카페의 동영상 데이터를 제공해 주는 API는 존재하지 않습니다.

1. <strong> 데이터의 유효성 부족 </strong>  
API와 크롤링의 특징을 비교할 때 가장 흔하게 마주할 수 있는 특징은 데이터의 신뢰성 입니다. 공식적으로 제공되는 데이터이기 때문에 API가 크롤링에 비해 신뢰성이 높다는 것이 일반적인 의견입니다. 이러한 특징에 더하여 직접적으로 원하는 데이터를 제공 받을수는 없지만, 검색 API를 사용한다면 간접적으로 데이터를 얻을수 있다라는 생각에 검색 API를 통해 얻는 데이터의 유효성을 판단했습니다.  
**제가 생각한 유효성의 기준은 받아오는 데이터 중 사용 가능한 게시글의 개수, 다시 말해 동영상이 포함되어 있으며 내가 가입한 카페일 확률입니다.**  
<br />
네이버가 제공하는 검색 API는 검색 키워드 1개에 대하여 최대 1000개의 카페 게시글 주소를 반환합니다.  
검색 결과가 일치할 경우 게시글의 공개, 비공개 여부를 상관하지 않고 결과를 반환합니다.  
다음은 위 조건을 토대로 진행한 실험의 결과입니다.  
  <details>
    <summary>실험 결과 일부</summary>
    <img width="100%" src="https://github.com/user-attachments/assets/45ddc943-0b44-4cec-b0d0-18e4544462ba" />
  </details>
  </br>
  각기 다른 검색 키워드를 통하여 여러 차례 실험해 봤지만, 결과의 수치는 크게 다르지 않았습니다. 반환되는 게시글 중 동영상을 포함한 게시글의 수는 100개를 기준으로 0개였으며, 5회 진행 시 1회 정도의 확률로 1~2개의 동영상을 포함한 게시글을 확인할 수 있었습니다.  
  이마저도 단순히 동영상을 포함한 게시글일 확률이며, 이 게시글이 내가 가입한 카페의 게시글일 확률은 0%에 수렴하고, 이 결과는 제가 생각한 데이터의 유효성 기준에 너무나 벗어난 수치였습니다.

</br>
이러한 제한 사항들에 의해 네이버 API가 아닌 다른 방법을 사용해 데이터를 가져오기로 했습니다.

### 1-2. 크롤링의 사용 이유

네이버 API를 사용하면 신뢰성 있는 데이터를 제공받을 수 있지만, 프로젝트에 필요한 데이터를 직접적으로 받을 수 없는 제한 사항이 존재했습니다.  
크롤링을 사용한다면 이런 제한 사항을 극복하고 프로젝트에 필요한 데이터를 직접적으로 확보할 수 있습니다.

1. 사용자 가입 카페 목록  
네이버 API로는 제공받을 수 없는 사용자 가입 카페 목록을, 크롤링을 통해 얻을 수 있게 됩니다. 사용자가 가입한 카페 목록은 물론이고, 이 목록을 활용해 해당 카페들의 게시글에 접근할 수 있습니다.

1. 데이터의 유효성 한계 극복  
검색 API를 사용할 경우, 반환되는 데이터의 대부분이 게시글에 접근조차 할 수 없는 비공개 게시글이거나, 동영상이 포함되지 않는 유효성이 없는 데이터들이었습니다. 크롤링을 사용한다면 이러한 유효성을 프로젝트의 필요성에 맞게 조정할 수 있었습니다.

### 1-3. 필요한 데이터 크롤링 순서
크롤링을 사용하기로 결정한 후, 필요한 데이터를 가져오는 로직의 순서는 다음과 같이 요약 가능합니다.

1. 로그인 이후 사용자가 가입한 모든 카페 주소 확보  
2. 각 카페의 전체 게시글 페이지로 이동  
3. 정해진 개수를 확보할때까지 페이지를 이동하며 동영상이 포함된 게시글 주소 확보  
4. 해당 게시글 주소로 이동하여 동영상 확보

이러한 과정을 통해 프로젝트에 필요한 데이터를 가져올 수 있게 되었습니다.

## 2. 동영상 데이터를 크롤링하는 방법

### 2-1. 게시글의 동영상 포함 여부 확인

동영상을 얻기 위해서는 게시글에 동영상이 포함되어 있는지 확인하는 것이 첫 번째 단계라 생각했습니다. 이때, 모든 게시글 내부에 접근하여 포함 여부를 판단하는 것은 비효율적이라 판단했고, 내부에 접근하지 않고 동영상의 포함 여부를 확인하는 방법을 찾았습니다.

<details>
  <summary>동영상 포함 여부 사진</summary>
  <img width="100%" src="https://github.com/user-attachments/assets/6ef2d471-097b-4d8f-b9ec-066faef714bc" />
</details>
</br>

해당 사진은 특정 카페의 전체 게시글 목록을 캡쳐한 사진입니다. 빨간색 동그라미 친 부분의 아이콘은 해당 게시글에 동영상이 포함되어 있음을 알려주는 아이콘입니다. 이 아이콘을 통해서 직접 게시글 내부에 접근하지 않아도 동영상의 포함 여부를 판단할 수 있게 되고, 해당 아이콘의 DOM 요소인 `span` 태그의 class 속성 `list-i-movie` 를 사용하여 전체 게시글 페이지만을 이동하며 동영상 포함 여부를 판단할 수 있었습니다.  

### 2-2. 예상하지 못한 크롤링 결과 데이터

게시글 내부에 접근하지 않고, 동영상의 포함 여부를 확인하는 방법을 찾은 이후 크롤링 로직을 구현하여 결과를 확인했지만 예상하지 못한 결과를 확인했습니다.  
분명히 로그인을 완료하고, 컨텐츠의 로딩을 기다린 후 `page.content()` 메서드를 사용하여 본문 크롤링을 시도했지만, 기대했던 결과와 전혀 다른 결과가 반환됐습니다. 이유는 네이버 카페 게시글 페이지의 `iframe DOM` 구조 때문이었습니다.  
iframe은 부모 페이지와 독립적인 DOM 트리를 형성합니다. 다시 한번 개발자 도구를 확인하여 크롤링하고자 했던 DOM의 최상위 요소를 확인해 보니 iframe 태그로 감싸져 있는 걸 확인 할 수 있었습니다.  
<details>
  <summary>최상위 iframe 확인 사진</summary>
  <img width="100%"  src="https://github.com/user-attachments/assets/542a9162-f2c5-4e86-aa60-189a9ca8f302" />
</details>
</br>

이를 해결 하기 위해 iframe 요소를 선택한 후, `contentFrame()` 메서드를 사용해 iframe 내부 `DOM 컨텍스트`를 확보하여 원하는 크롤링 데이터를 얻을 수 있게 되었습니다.
```javascript
const iframeElement = await page.$("iframe#cafe_main");
let iframe = await iframeElement.contentFrame();
```

### 2-3. 게시글로부터 동영상 데이터 확보

동영상이 포함된 게시글 주소를 확보한 이후, 동영상 데이터를 가져오기 위한 로직을 구현하기 시작했습니다.  
이를 위해 게시글 내부 video 태그의 `src` 속성을 확인했습니다.

<details>
  <summary>초기 video 태그 속성 확인 사진</summary>
  <img width="100%"  src="https://github.com/user-attachments/assets/4234e6fb-da05-4114-b52b-aa77987d3b42" />
</details>
</br>

당연하게 존재할 것이라 생각한 video 태그의 src 속성은 존재하지 않았습니다. 해당 속성은 게시글 접근 초기에는 존재하지 않다가 동영상의 재생버튼을 클릭한 이후, 동적으로 생성되었습니다.

<details>
  <summary>재생버튼 클릭 이후, video 태그 속성 확인 사진</summary>
  <img width="100%" src="https://github.com/user-attachments/assets/cb6827bd-c2e7-4dbb-822d-fa578d94df6c" />
</details>
</br>

이러한 구조라면 게시글에 접근하여 재생 버튼을 클릭한 다음, 다시 DOM 요소를 불러와야 하는 흐름이었고, 이 한 단계의 추가적인 행동이 동영상이 포함된 모든 게시글마다 실행된다면 크롤링 속도 저하에 영향을 끼친다고 판단했습니다.

해결하기 위한 방법을 찾던 중, 동영상 재생 시 스트리밍되는 데이터와 별개로 네트워크 요청에서 초기 데이터를 받아오는 경우가 있다는 정보를 얻었습니다. 실제로 네트워크 요청 탭을 확인해 보니, 수많은 요청 주소 중 해당 게시글의 동영상 데이터를 갖는 응답을 확인할 수 있었습니다.

<details>
  <summary>네트워크 요청 중 동영상 데이터를 갖는 응답 사진</summary>
  <img width="100%" src="https://github.com/user-attachments/assets/2a775417-f6f9-4350-a490-173c3568b492" />
</details>
</br>

게시글 접속 시 발생하는 수많은 네트워크 요청 가운데, 동영상 데이터를 갖는 응답은 다른 요청들과는 다르게 유일한 주소 패턴을 갖고 있었습니다.  
```javascript
if (requestUrl.includes("apis.naver.com/rmcnmv/rmcnmv/vod/play"))
```
이러한 특징 덕분에 모든 네트워크 요청을 일일이 확인할 필요 없이 조건문 하나로 빠르게 필요한 네트워크 요청을 확인 할 수 있었고, 동영상 데이터를 가져올 수 있게 되었습니다.

</br>

# 🖼 사용자 경험 개선

## 1. 대기 시간 없는 영상 시청
카페 한개에 대하여 5개의 동영상 데이터를 가져와 사용자에게 보여주기까지 평균적으로 30초에서 50초 정도의 시간이 소요됩니다.  
이 시간은 크롤링을 위한 최소한의 시간으로 더 이상 단축이 불가능했습니다.
이러한 대기 시간동안 사용자 경험을 향상시키기 위해 다음과 같은 방식을 구현했습니다.

### 1-1. 초기 동영상 우선 제공
사용자별로 가입한 카페의 개수는 모두 다릅니다. 이때 가입 카페 목록 중 최상단에 있는 카페는 가장 많이 접속하는 카페이고, 해당 카페의 동영상을 우선으로 크롤링하여 사용자에게 보여줍니다. 초기 크롤링 대기 시간 동안 사용자에게 프로젝트 기능에 대한 소개 영상을 제공하여 단순히 기다리기만 하는것이 아닌 프로젝트의 전반적인 기능을 살펴볼 수 있는 경험을 제공했습니다.

### 1-2. 병렬 요청을 통한 나머지 카페의 동영상 제공
사용자가 첫 번째 카페의 동영상을 즐기는 동안, 화면 뒤에서는 가입한 나머지 카페에 대하여 동영상 데이터를 병렬적으로 크롤링합니다. 한 번에 3개의 카페에 대한 크롤링 요청을 병렬로 처리하여, 요청이 완료되는 순서대로 사용자에게 동영상을 제공합니다.  해당 병렬 요청은 가입한 모든 카페에 대한 요청이 완료될 때까지 반복됩니다.

사용자가 첫 번째 카페의 동영상을 즐기는 동안, 화면 뒤에서는 가입한 나머지 카페에 대하여 동영상 데이터를 병렬적으로 크롤링합니다. 한 번에 3개의 카페에 대한 크롤링 요청을 병렬로 처리합니다. 해당 병렬 요청은 가입한 모든 카페에 대한 요청이 완료될 때까지 반복됩니다. 이때, 3개의 요청에 대한 모든 응답을 기다렸다 한 번에 반환하는 것이 아니라 요청이 먼저 완료되는 순서대로 사용자에게 동영상을 제공하여, 사용자가 기다리는 대기 시간을 감소시켰습니다.

### 1-3. 중복 없는 추가 동영상 제공
이미 동영상을 가져온 카페에 대해서도 중복되지 않는 추가적인 동영상을 제공합니다. 사용자가 한 카페에 대한 동영상 시청을 시작하는 그 순간, 추가적인 동영상에 대한 크롤링 요청을 전송합니다. 화면 뒤에서는 해당 요청에 대한 응답으로 중복되지 않는 동영상 데이터를 사용자에게 전송해 줍니다. 이것이 가능한 이유는 전체 게시글의 마지막 페이지 정보를 기억하기 때문입니다.  
서버에서는 크롤링 응답의 매 순간 마지막으로 크롤링을 완료한 페이지 숫자를 함께 클라이언트에게 전달합니다. 클라이언트는 해당 숫자를 전달 받아 저장하고 있다가 사용자가 영상을 시청하는 순간 서버에 크롤링 요청을 보냄과 동시에 저장하고 있던 페이지 숫자도 함께 전달합니다. 서버는 이 숫자를 기준으로 다음 페이지부터 크롤링을 시작하여 중복되지 않는 동영상을 사용자에게 제공할 수 있게 됩니다.

**이러한 방식을 통하여 사용자는 대기시간과 중복이 없는 동영상 콘텐츠를 경험할 수 있게됩니다.**

## 2. 동영상 개수 표기
개발자는 카페 한 개에 대하여 몇 개의 동영상을 가져오는지 알 수 있지만, 사용자는 알 수가 없습니다.  
초기 개발 단계에서는 단순히 화면에 동영상을 보여주었지만, 내가 볼 수 있는 동영상이 몇 개인지, 또 현재 시청 중인 동영상이 몇 번째인지 알 수 있다면 사용자 경험이 향상될 것으로 생각하여 화면에 동영상 개수를 명시적으로 나타내었습니다.

<details>
  <summary>개수 표기 전후 사진</summary>
  <table>
  <tr>
    <td width="50%">
      <img width="100%" src="https://github.com/user-attachments/assets/a57636a9-4102-4039-b6f5-411835c3f6a0" />
    </td>
    <td width="50%">
      <img width="100%" src="https://github.com/user-attachments/assets/4ff402e9-8747-42f7-8225-2d9af2b55cea" />
    </td>
  </tr>
  <tr align="center">
    <td>전</td>
    <td>후</td>
  </tr>
</table>
</details>

### 2-1. 영상의 재생 정도 표기
영상의 개수를 나타낸 이후, 현재 진행 중인 동영상이 어느 정도 길이인지 알 수 있다면 좋지 않을까? 하는 아이디어가 떠올랐습니다. 동영상을 클릭하면 해당 영상의 길이를 직관적으로 알 수 있지만, 거의 모든 사용자는 동영상을 시청할 때는 오롯이 화면만 보기를 원할 것입니다.  
이 아이디어를 구현하기 위해 기존에 단순히 동영상 개수만을 나타내던 상단 프로그레스바가 동영상 길이와 재생 진행률에 따라 동적으로 채워지도록 UI를 변경했습니다.

이러한 화면의 개선 작업을 통하여 사용자 경험 개선을 구현할 수 있었습니다.

# 프로젝트 후기
팀 프로젝트가 끝난 이후 진행한 개인 프로젝트라 팀의 소중함이 더 크게 다가왔던 시간이었습니다.
팀으로 진행할 때는 내 생각에 대한 피드백이 즉각적으로 돌아왔고, 그로 인해 의사결정을 빠르게 바른 방향으로 내릴 수 있었습니다. 하지만, 이번 프로젝트는 처음 기획부터 마무리까지 모든 단계를 오롯이 나의 생각으로만 방향을 잡아가야 했기에 어려움이 컸었습니다.  
이러한 시간속에, 내가 정한 방향이 항상 옳은 방향은 아니지만 최소한 더 긍정적이며 바른 방향으로 나아가는 방법을 배웠다고 생각합니다. 앞으로 실무에서도 항상 더 바른 방향성에 대해 고민을 하는 개발자가 되고자 합니다.
